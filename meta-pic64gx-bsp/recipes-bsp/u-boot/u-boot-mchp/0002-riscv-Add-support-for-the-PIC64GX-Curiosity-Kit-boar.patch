From a928bc4bba953672a8bbf6711cd3419ebbd6afb0 Mon Sep 17 00:00:00 2001
From: Pierre-Henry Moussay <pierre-henry.moussay@microchip.com>
Date: Fri, 18 Oct 2024 17:34:25 +0100
Subject: [u-boot-mchp][PATCH 2/2] riscv: Add support for the PIC64GX Curiosity
 Kit board support

The Curiosity-GX10000 (PIC64GX SoC Curiosity Kit) is a compact SoC
prototyping board featuring a Microchip PIC64GX SoC
PIC64GX-1000. Features include:
- 1 GB DDR4 SDRAM
- Gigabit Ethernet
- microSD-card slot

Signed-off-by: Pierre-Henry Moussay <pierre-henry.moussay@microchip.com>
---
 arch/riscv/Kconfig                            |  12 +
 arch/riscv/dts/Makefile                       |   2 +
 arch/riscv/dts/pic64gx-curiosity-kit.dts      | 114 ++++
 arch/riscv/dts/pic64gx.dtsi                   | 624 ++++++++++++++++++
 board/microchip/pic64gx_curiosity_kit/Kconfig |  44 ++
 .../pic64gx_curiosity_kit/MAINTAINERS         |   7 +
 .../microchip/pic64gx_curiosity_kit/Makefile  |   6 +
 .../pic64gx_curiosity_kit.c                   | 377 +++++++++++
 .../microchip_pic64gx_curiosity_kit_defconfig |  30 +
 .../configs/microchip_pic64gx_curiosity_kit.h |  72 ++
 10 files changed, 1288 insertions(+)
 create mode 100644 arch/riscv/dts/pic64gx-curiosity-kit.dts
 create mode 100644 arch/riscv/dts/pic64gx.dtsi
 create mode 100644 board/microchip/pic64gx_curiosity_kit/Kconfig
 create mode 100644 board/microchip/pic64gx_curiosity_kit/MAINTAINERS
 create mode 100644 board/microchip/pic64gx_curiosity_kit/Makefile
 create mode 100644 board/microchip/pic64gx_curiosity_kit/pic64gx_curiosity_kit.c
 create mode 100644 configs/microchip_pic64gx_curiosity_kit_defconfig
 create mode 100644 include/configs/microchip_pic64gx_curiosity_kit.h

diff --git a/arch/riscv/Kconfig b/arch/riscv/Kconfig
index 8892a0e870..ac2ab8f271 100644
--- a/arch/riscv/Kconfig
+++ b/arch/riscv/Kconfig
@@ -23,6 +23,17 @@ config TARGET_MICROCHIP_ICICLE
 config TARGET_MICROCHIP_DISCOKIT
 	bool "Support Microchip PolarFire-SoC Discovery Board"
 
+config TARGET_MICROCHIP_PIC64GX_CURIOSITY
+	bool "Support Microchip PIC64GX-SoC Curiosity Kit"
+	help
+	  Support for Microchip PIC64GX Curiosity Kit platform.
+	  The Curiosity-GX10000 (PIC64GX SoC Curiosity Kit) is a compact SoC
+	  prototyping board featuring a Microchip PIC64GX SoC
+	  PIC64GX-1000. Features include:
+	  - 1 GB DDR4 SDRAM
+	  - Gigabit Ethernet
+	  - microSD-card slot
+
 config TARGET_MICROCHIP_VIDEOKIT
 	bool "Support Microchip PolarFire-SoC Video Kit"
 
@@ -87,6 +98,7 @@ source "board/emulation/qemu-riscv/Kconfig"
 source "board/microchip/mpfs_icicle/Kconfig"
 source "board/microchip/mpfs_discokit/Kconfig"
 source "board/microchip/mpfs_videokit/Kconfig"
+source "board/microchip/pic64gx_curiosity_kit/Kconfig"
 source "board/sundancedsp/polarberry/Kconfig"
 source "board/sifive/unleashed/Kconfig"
 source "board/sifive/unmatched/Kconfig"
diff --git a/arch/riscv/dts/Makefile b/arch/riscv/dts/Makefile
index 287034676a..071626be55 100644
--- a/arch/riscv/dts/Makefile
+++ b/arch/riscv/dts/Makefile
@@ -8,6 +8,8 @@ dtb-$(CONFIG_TARGET_MICROCHIP_ICICLE) += microchip-mpfs-icicle-kit.dtb \
 microchip-mpfs-icicle-kit-amp.dtb microchip-mpfs-icicle-kit-qspi-nor.dtb
 dtb-$(CONFIG_TARGET_MICROCHIP_DISCOKIT) += microchip-mpfs-disco-kit.dtb
 dtb-$(CONFIG_TARGET_MICROCHIP_VIDEOKIT) += microchip-mpfs-video-kit.dtb
+dtb-$(CONFIG_TARGET_MICROCHIP_PIC64GX_CURIOSITY) += \
+pic64gx-curiosity-kit.dtb
 dtb-$(CONFIG_TARGET_SUNDANCEDSP_POLARBERRY) += mpfs-polarberry.dtb
 dtb-$(CONFIG_TARGET_QEMU_VIRT) += qemu-virt32.dtb qemu-virt64.dtb
 dtb-$(CONFIG_TARGET_OPENPITON_RISCV64) += openpiton-riscv64.dtb
diff --git a/arch/riscv/dts/pic64gx-curiosity-kit.dts b/arch/riscv/dts/pic64gx-curiosity-kit.dts
new file mode 100644
index 0000000000..356877829e
--- /dev/null
+++ b/arch/riscv/dts/pic64gx-curiosity-kit.dts
@@ -0,0 +1,114 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/* Copyright (c) 2024 Microchip Technology Inc */
+
+/dts-v1/;
+
+#include "pic64gx.dtsi"
+
+/* Clock frequency (in Hz) of the rtcclk */
+#define RTCCLK_FREQ	1000000
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+	model = "Microchip PIC64GX Curiosity Kit";
+	compatible = "microchip,pic64gx-curiosity-kit", "microchip,pic64gx";
+
+	aliases {
+		ethernet0 = &mac0;
+		serial1 = &mmuart1;
+		serial2 = &mmuart2;
+	};
+
+	chosen {
+		stdout-path = "serial1:115200n8";
+	};
+
+	cpus {
+		timebase-frequency = <RTCCLK_FREQ>;
+	};
+
+	memory@80000000 {
+		device_type = "memory";
+		reg = <0x0 0x80000000 0x0 0x40000000>;
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		hss: hss-buffer@bfc00000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0xbfc00000 0x0 0x400000>;
+			no-map;
+		};
+	};
+};
+
+&gpio0 {
+	status ="okay";
+	gpio-line-names =
+		"", "", "", "", "", "", "", "",
+		"", "", "", "", "MIPI_CAM_RESET", "MIPI_CAM_STANDBY";
+};
+
+&gpio1 {
+	status ="okay";
+	gpio-line-names =
+		"", "", "LED1", "LED2", "LED3", "LED4", "LED5", "LED6",
+		"LED7", "LED8", "", "", "", "", "", "",
+		"", "", "", "", "HDMI_HPD", "", "", "GPIO_1_23";
+};
+
+&gpio2 {
+	status ="okay";
+	gpio-line-names =
+		"", "", "", "", "", "", "SWITCH2", "USR_IO12",
+		"DIP1", "DIP2", "", "DIP3", "USR_IO1", "USR_IO2", "USR_IO7", "USR_IO8",
+		"USR_IO3", "USR_IO4", "USR_IO5", "USR_IO6", "", "", "USR_IO9", "USR_IO10",
+		"DIP4", "USR_IO11", "", "", "SWITCH1", "", "", "";
+};
+
+&mac0 {
+	status = "okay";
+	phy-mode = "sgmii";
+	phy-handle = <&phy0>;
+
+	phy0: ethernet-phy@b {
+		reg = <0xb>;
+	};
+};
+
+&mbox {
+	status = "okay";
+};
+
+&mmc {
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-mmc-highspeed;
+	sdhci-caps-mask = <0x00000007 0x00000000>;
+	status = "okay";
+};
+
+&mmuart1 {
+	status = "okay";
+};
+
+&mmuart2 {
+	status = "okay";
+};
+
+&refclk {
+	clock-frequency = <125000000>;
+};
+
+&rtc {
+	status = "okay";
+};
+
+&syscontroller {
+	status = "okay";
+};
diff --git a/arch/riscv/dts/pic64gx.dtsi b/arch/riscv/dts/pic64gx.dtsi
new file mode 100644
index 0000000000..7a91eca92a
--- /dev/null
+++ b/arch/riscv/dts/pic64gx.dtsi
@@ -0,0 +1,624 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/* Copyright (c) 2024 Microchip Technology Inc */
+
+/dts-v1/;
+#include "dt-bindings/clock/microchip-mpfs-clock.h"
+#include <dt-bindings/interrupt-controller/irq.h>
+
+/ {
+	#address-cells = <2>;
+	#size-cells = <2>;
+	model = "Microchip PIC64GX SoC";
+	compatible = "microchip,pic64gx";
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "sifive,e51", "sifive,rocket0", "riscv";
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <128>;
+			i-cache-size = <16384>;
+			reg = <0>;
+			riscv,isa = "rv64imac";
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "c", "zicntr", "zicsr",
+					       "zifencei", "zihpm";
+			clocks = <&clkcfg CLK_CPU>;
+			status = "disabled";
+
+			cpu0_intc: interrupt-controller {
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu1: cpu@1 {
+			compatible = "sifive,u54-mc", "sifive,rocket0", "riscv";
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <32>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <32>;
+			mmu-type = "riscv,sv39";
+			reg = <1>;
+			riscv,isa = "rv64imafdc";
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "zicntr",
+					       "zicsr", "zifencei", "zihpm";
+			clocks = <&clkcfg CLK_CPU>;
+			tlb-split;
+			next-level-cache = <&cctrllr>;
+			status = "okay";
+
+			cpu1_intc: interrupt-controller {
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu2: cpu@2 {
+			compatible = "sifive,u54-mc", "sifive,rocket0", "riscv";
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <32>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <32>;
+			mmu-type = "riscv,sv39";
+			reg = <2>;
+			riscv,isa = "rv64imafdc";
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "zicntr",
+					       "zicsr", "zifencei", "zihpm";
+			clocks = <&clkcfg CLK_CPU>;
+			tlb-split;
+			next-level-cache = <&cctrllr>;
+			status = "okay";
+
+			cpu2_intc: interrupt-controller {
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu3: cpu@3 {
+			compatible = "sifive,u54-mc", "sifive,rocket0", "riscv";
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <32>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <32>;
+			mmu-type = "riscv,sv39";
+			reg = <3>;
+			riscv,isa = "rv64imafdc";
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "zicntr",
+					       "zicsr", "zifencei", "zihpm";
+			clocks = <&clkcfg CLK_CPU>;
+			tlb-split;
+			next-level-cache = <&cctrllr>;
+			status = "okay";
+
+			cpu3_intc: interrupt-controller {
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu4: cpu@4 {
+			compatible = "sifive,u54-mc", "sifive,rocket0", "riscv";
+			d-cache-block-size = <64>;
+			d-cache-sets = <64>;
+			d-cache-size = <32768>;
+			d-tlb-sets = <1>;
+			d-tlb-size = <32>;
+			device_type = "cpu";
+			i-cache-block-size = <64>;
+			i-cache-sets = <64>;
+			i-cache-size = <32768>;
+			i-tlb-sets = <1>;
+			i-tlb-size = <32>;
+			mmu-type = "riscv,sv39";
+			reg = <4>;
+			riscv,isa = "rv64imafdc";
+			riscv,isa-base = "rv64i";
+			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "zicntr",
+					       "zicsr", "zifencei", "zihpm";
+			clocks = <&clkcfg CLK_CPU>;
+			tlb-split;
+			next-level-cache = <&cctrllr>;
+			status = "okay";
+			cpu4_intc: interrupt-controller {
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+				compatible = "riscv,cpu-intc";
+				interrupt-controller;
+			};
+		};
+
+		cpu-map {
+			cluster0 {
+				core0 {
+					cpu = <&cpu0>;
+				};
+
+				core1 {
+					cpu = <&cpu1>;
+				};
+
+				core2 {
+					cpu = <&cpu2>;
+				};
+
+				core3 {
+					cpu = <&cpu3>;
+				};
+
+				core4 {
+					cpu = <&cpu4>;
+				};
+			};
+		};
+	};
+
+	scbclk: clock-80000000 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <80000000>;
+	};
+
+	refclk: mssrefclk {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+
+	syscontroller: syscontroller {
+		compatible = "microchip,pic64gx-sys-controller";
+		mboxes = <&mbox 0>;
+	};
+
+	soc {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		compatible = "simple-bus";
+		ranges;
+
+		clint: clint@2000000 {
+			compatible = "microchip,pic64gx-clint", "sifive,clint0";
+			reg = <0x0 0x2000000 0x0 0xC000>;
+			interrupts-extended = <&cpu0_intc 0xffffffff>, <&cpu0_intc 0xffffffff>,
+					      <&cpu1_intc 3>, <&cpu1_intc 7>,
+					      <&cpu2_intc 3>, <&cpu2_intc 7>,
+					      <&cpu3_intc 3>, <&cpu3_intc 7>,
+					      <&cpu4_intc 3>, <&cpu4_intc 7>;
+		};
+
+		cctrllr: cache-controller@2010000 {
+			compatible = "microchip,pic64gx-ccache", "microchip,mpfs-ccache",
+				     "sifive,fu540-c000-ccache", "cache";
+			reg = <0x0 0x2010000 0x0 0x1000>;
+			cache-block-size = <64>;
+			cache-level = <2>;
+			cache-sets = <1024>;
+			cache-size = <2097152>;
+			cache-unified;
+			interrupt-parent = <&plic>;
+			interrupts = <1>, <3>, <4>, <2>;
+		};
+
+		pdma: dma-controller@3000000 {
+			compatible = "microchip,pic64gx-pdma", "microchip,mpfs-pdma",
+				     "sifive,fu540-c000-pdma";
+			reg = <0x0 0x3000000 0x0 0x8000>;
+			interrupt-parent = <&plic>;
+			interrupts = <5 6>, <7 8>, <9 10>, <11 12>;
+			#dma-cells = <1>;
+		};
+
+		plic: interrupt-controller@c000000 {
+			compatible = "microchip,pic64gx-plic", "sifive,plic-1.0.0";
+			reg = <0x0 0xc000000 0x0 0x4000000>;
+			#address-cells = <0>;
+			#interrupt-cells = <1>;
+			interrupt-controller;
+			interrupts-extended = <&cpu0_intc 0xffffffff>,
+					      <&cpu1_intc 0xffffffff>, <&cpu1_intc 9>,
+					      <&cpu2_intc 0xffffffff>, <&cpu2_intc 9>,
+					      <&cpu3_intc 0xffffffff>, <&cpu3_intc 9>,
+					      <&cpu4_intc 0xffffffff>, <&cpu4_intc 9>;
+			riscv,ndev = <186>;
+		};
+
+		mmuart0: serial@20000000 {
+			compatible = "ns16550a";
+			reg = <0x0 0x20000000 0x0 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupt-parent = <&plic>;
+			interrupts = <90>;
+			current-speed = <115200>;
+			clocks = <&clkcfg CLK_MMUART0>;
+			status = "disabled"; /* Reserved for the HSS */
+		};
+
+		mss_top_sysreg: syscon@20002000 {
+			compatible = "microchip,pic64gx-mss-top-sysreg",
+				     "microchip,mpfs-mss-top-sysreg",
+				     "syscon", "simple-mfd";
+			reg = <0x0 0x20002000 0x0 0x1000>;
+			#reset-cells = <1>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			irqmux: interrupt-controller@54 {
+				compatible = "microchip,pic64gx-gpio-irq-mux",
+					     "microchip,mpfs-gpio-irq-mux";
+				reg = <0x54 0x4>;
+				interrupt-parent = <&plic>;
+				interrupt-controller;
+				#address-cells = <0>;
+				#interrupt-cells = <1>;
+				interrupts = <13>, <14>, <15>, <16>,
+					     <17>, <18>, <19>, <20>,
+					     <21>, <22>, <23>, <24>,
+					     <25>, <26>, <27>, <28>,
+					     <29>, <30>, <31>, <32>,
+					     <33>, <34>, <35>, <36>,
+					     <37>, <38>, <39>, <40>,
+					     <41>, <42>, <43>, <44>,
+					     <45>, <46>, <47>, <48>,
+					     <49>, <50>, <51>, <52>,
+					     <53>;
+			};
+		};
+
+		sysreg_scb: syscon@20003000 {
+			compatible = "microchip,pic64gx-sysreg-scb",
+				     "microchip,mpfs-sysreg-scb",
+				     "syscon";
+			reg = <0x0 0x20003000 0x0 0x1000>;
+		};
+
+		/* Common node entry for emmc/sd */
+		mmc: mmc@20008000 {
+			compatible = "microchip,pic64gx-sd4hc", "cdns,sd4hc";
+			reg = <0x0 0x20008000 0x0 0x1000>;
+			interrupt-parent = <&plic>;
+			interrupts = <88>;
+			clocks = <&clkcfg CLK_MMC>;
+			max-frequency = <200000000>;
+			status = "disabled";
+		};
+
+		mmuart1: serial@20100000 {
+			compatible = "ns16550a";
+			reg = <0x0 0x20100000 0x0 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupt-parent = <&plic>;
+			interrupts = <91>;
+			current-speed = <115200>;
+			clocks = <&clkcfg CLK_MMUART1>;
+			status = "disabled";
+		};
+
+		mmuart2: serial@20102000 {
+			compatible = "ns16550a";
+			reg = <0x0 0x20102000 0x0 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupt-parent = <&plic>;
+			interrupts = <92>;
+			current-speed = <115200>;
+			clocks = <&clkcfg CLK_MMUART2>;
+			status = "disabled";
+		};
+
+		mmuart3: serial@20104000 {
+			compatible = "ns16550a";
+			reg = <0x0 0x20104000 0x0 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupt-parent = <&plic>;
+			interrupts = <93>;
+			current-speed = <115200>;
+			clocks = <&clkcfg CLK_MMUART3>;
+			status = "disabled";
+		};
+
+		mmuart4: serial@20106000 {
+			compatible = "ns16550a";
+			reg = <0x0 0x20106000 0x0 0x400>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			interrupt-parent = <&plic>;
+			interrupts = <94>;
+			clocks = <&clkcfg CLK_MMUART4>;
+			current-speed = <115200>;
+			status = "disabled";
+		};
+
+		spi0: spi@20108000 {
+			compatible = "microchip,pic64gx-spi", "microchip,mpfs-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x20108000 0x0 0x1000>;
+			interrupt-parent = <&plic>;
+			interrupts = <54>;
+			clocks = <&clkcfg CLK_SPI0>;
+			status = "disabled";
+		};
+
+		spi1: spi@20109000 {
+			compatible = "microchip,pic64gx-spi", "microchip,mpfs-spi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x20109000 0x0 0x1000>;
+			interrupt-parent = <&plic>;
+			interrupts = <55>;
+			clocks = <&clkcfg CLK_SPI1>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@2010a000 {
+			compatible = "microchip,pic64gx-i2c", "microchip,corei2c-rtl-v7";
+			reg = <0x0 0x2010a000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupt-parent = <&plic>;
+			interrupts = <58>;
+			clocks = <&clkcfg CLK_I2C0>;
+			clock-frequency = <100000>;
+			status = "disabled";
+		};
+
+		i2c1: i2c@2010b000 {
+			compatible = "microchip,pic64gx-i2c", "microchip,corei2c-rtl-v7";
+			reg = <0x0 0x2010b000 0x0 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupt-parent = <&plic>;
+			interrupts = <61>;
+			clocks = <&clkcfg CLK_I2C1>;
+			clock-frequency = <100000>;
+			status = "disabled";
+		};
+
+		can0: can@2010c000 {
+			compatible = "microchip,pic64gx-can", "microchip,mpfs-can";
+			reg = <0x0 0x2010c000 0x0 0x1000>;
+			clocks = <&clkcfg CLK_CAN0>, <&clkcfg CLK_MSSPLL3>;
+			interrupt-parent = <&plic>;
+			interrupts = <56>;
+			resets = <&mss_top_sysreg CLK_CAN0>;
+			status = "disabled";
+		};
+
+		can1: can@2010d000 {
+			compatible = "microchip,pic64gx-can", "microchip,mpfs-can";
+			reg = <0x0 0x2010d000 0x0 0x1000>;
+			clocks = <&clkcfg CLK_CAN1>, <&clkcfg CLK_MSSPLL3>;
+			interrupt-parent = <&plic>;
+			interrupts = <57>;
+			resets = <&mss_top_sysreg CLK_CAN1>;
+			status = "disabled";
+		};
+
+		mac0: ethernet@20110000 {
+			compatible = "microchip,pic64gx-macb", "microchip,mpfs-macb",
+				     "cdns,macb";
+			reg = <0x0 0x20110000 0x0 0x2000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupt-parent = <&plic>;
+			interrupts = <64>, <65>, <66>, <67>, <68>, <69>;
+			/* Filled in by a bootloader */
+			local-mac-address = [00 00 00 00 00 00];
+			clocks = <&clkcfg CLK_MAC0>, <&clkcfg CLK_AHB>;
+			clock-names = "pclk", "hclk";
+			resets = <&mss_top_sysreg CLK_MAC0>;
+			status = "disabled";
+		};
+
+		mac1: ethernet@20112000 {
+			compatible = "microchip,pic64gx-macb", "microchip,mpfs-macb",
+				     "cdns,macb";
+			reg = <0x0 0x20112000 0x0 0x2000>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			interrupt-parent = <&plic>;
+			interrupts = <70>, <71>, <72>, <73>, <74>, <75>;
+			/* Filled in by a bootloader */
+			local-mac-address = [00 00 00 00 00 00];
+			clocks = <&clkcfg CLK_MAC1>, <&clkcfg CLK_AHB>;
+			clock-names = "pclk", "hclk";
+			resets = <&mss_top_sysreg CLK_MAC1>;
+			status = "disabled";
+		};
+
+		gpio0: gpio@20120000 {
+			compatible = "microchip,pic64gx-gpio", "microchip,mpfs-gpio";
+			reg = <0x0 0x20120000 0x0 0x1000>;
+			interrupt-parent = <&irqmux>;
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			interrupts = <0>, <1>, <2>, <3>,
+				     <4>, <5>, <6>, <7>,
+				     <8>, <9>, <10>, <11>,
+				     <12>, <13>;
+			clocks = <&clkcfg CLK_GPIO0>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			ngpios = <14>;
+			status = "disabled";
+		};
+
+		gpio1: gpio@20121000 {
+			compatible = "microchip,pic64gx-gpio", "microchip,mpfs-gpio";
+			reg = <0x0 0x20121000 0x0 0x1000>;
+			interrupt-parent = <&irqmux>;
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			interrupts = <32>, <33>, <34>, <35>,
+				     <36>, <37>, <38>, <39>,
+				     <40>, <41>, <42>, <43>,
+				     <44>, <45>, <46>, <47>,
+				     <48>, <49>, <50>, <51>,
+				     <52>, <53>, <54>, <55>;
+			clocks = <&clkcfg CLK_GPIO1>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			ngpios = <24>;
+			status = "disabled";
+		};
+
+		gpio2: gpio@20122000 {
+			compatible = "microchip,pic64gx-gpio", "microchip,mpfs-gpio";
+			reg = <0x0 0x20122000 0x0 0x1000>;
+			interrupt-parent = <&irqmux>;
+			interrupt-controller;
+			#address-cells = <0>;
+			#interrupt-cells = <2>;
+			interrupts = <64>, <65>, <66>, <67>,
+				     <68>, <69>, <70>, <71>,
+				     <72>, <73>, <74>, <75>,
+				     <76>, <77>, <78>, <79>,
+				     <80>, <81>, <82>, <83>,
+				     <84>, <85>, <86>, <87>,
+				     <88>, <89>, <90>, <91>,
+				     <92>, <93>, <94>, <95>;
+			clocks = <&clkcfg CLK_GPIO2>;
+			gpio-controller;
+			#gpio-cells = <2>;
+			ngpios = <32>;
+			status = "disabled";
+		};
+
+		rtc: rtc@20124000 {
+			compatible = "microchip,pic64gx-rtc", "microchip,mpfs-rtc";
+			reg = <0x0 0x20124000 0x0 0x1000>;
+			interrupt-parent = <&plic>;
+			interrupts = <80>, <81>;
+			clocks = <&clkcfg CLK_RTC>, <&clkcfg CLK_RTCREF>;
+			clock-names = "rtc", "rtcref";
+			status = "disabled";
+		};
+
+		usb: usb@20201000 {
+			compatible = "microchip,pic64gx-musb", "microchip,mpfs-musb";
+			reg = <0x0 0x20201000 0x0 0x1000>;
+			interrupt-parent = <&plic>;
+			interrupts = <86>, <87>;
+			clocks = <&clkcfg CLK_USB>;
+			interrupt-names = "dma", "mc";
+			status = "disabled";
+		};
+
+		qspi: spi@21000000 {
+			compatible = "microchip,pic64gx-qspi", "microchip,coreqspi-rtl-v2";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x21000000 0x0 0x1000>;
+			interrupt-parent = <&plic>;
+			interrupts = <85>;
+			clocks = <&clkcfg CLK_QSPI>;
+			status = "disabled";
+		};
+
+		control_scb: syscon@37020000 {
+			compatible = "microchip,pic64gx-control-scb",
+				     "microchip,mpfs-control-scb",
+				     "syscon", "simple-mfd";
+			reg = <0x0 0x37020000 0x0 0x100>;
+		};
+
+		syscontroller_qspi: spi@37020100 {
+			compatible = "microchip,pic64gx-qspi", "microchip,coreqspi-rtl-v2";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x37020100 0x0 0x100>;
+			interrupt-parent = <&plic>;
+			interrupts = <110>;
+			clocks = <&scbclk>;
+			status = "disabled";
+		};
+
+		mbox: mailbox@37020800 {
+			compatible = "microchip,pic64gx-mailbox", "microchip,mpfs-mailbox";
+			reg = <0x0 0x37020800 0x0 0x100>;
+			interrupt-parent = <&plic>;
+			interrupts = <96>;
+			#mbox-cells = <1>;
+			status = "disabled";
+		};
+
+		ccc_se: clock-controller@38010000 {
+			compatible = "microchip,pic64gx-ccc", "microchip,mpfs-ccc";
+			reg = <0x0 0x38010000 0x0 0x1000>, <0x0 0x38020000 0x0 0x1000>,
+			      <0x0 0x39010000 0x0 0x1000>, <0x0 0x39020000 0x0 0x1000>;
+			#clock-cells = <1>;
+			status = "disabled";
+		};
+
+		ccc_ne: clock-controller@38040000 {
+			compatible = "microchip,pic64gx-ccc", "microchip,mpfs-ccc";
+			reg = <0x0 0x38040000 0x0 0x1000>, <0x0 0x38080000 0x0 0x1000>,
+			      <0x0 0x39040000 0x0 0x1000>, <0x0 0x39080000 0x0 0x1000>;
+			#clock-cells = <1>;
+			status = "disabled";
+		};
+
+		ccc_nw: clock-controller@38100000 {
+			compatible = "microchip,pic64gx-ccc", "microchip,mpfs-ccc";
+			reg = <0x0 0x38100000 0x0 0x1000>, <0x0 0x38200000 0x0 0x1000>,
+			      <0x0 0x39100000 0x0 0x1000>, <0x0 0x39200000 0x0 0x1000>;
+			#clock-cells = <1>;
+			status = "disabled";
+		};
+
+		ccc_sw: clock-controller@38400000 {
+			compatible = "microchip,pic64gx-ccc", "microchip,mpfs-ccc";
+			reg = <0x0 0x38400000 0x0 0x1000>, <0x0 0x38800000 0x0 0x1000>,
+			      <0x0 0x39400000 0x0 0x1000>, <0x0 0x39800000 0x0 0x1000>;
+			#clock-cells = <1>;
+			status = "disabled";
+		};
+
+		clkcfg: clkcfg@3e001000 {
+			compatible = "microchip,pic64gx-clkcfg", "microchip,mpfs-clkcfg";
+			reg = <0x0 0x3e001000 0x0 0x1000>;
+			clocks = <&refclk>;
+			#clock-cells = <1>;
+		};
+	};
+};
diff --git a/board/microchip/pic64gx_curiosity_kit/Kconfig b/board/microchip/pic64gx_curiosity_kit/Kconfig
new file mode 100644
index 0000000000..359bd537b8
--- /dev/null
+++ b/board/microchip/pic64gx_curiosity_kit/Kconfig
@@ -0,0 +1,44 @@
+if TARGET_MICROCHIP_PIC64GX_CURIOSITY
+
+config SYS_BOARD
+       default "pic64gx_curiosity_kit"
+
+config SYS_VENDOR
+       default "microchip"
+
+config SYS_CPU
+       default "mpfs"
+
+config SYS_CONFIG_NAME
+       default "microchip_pic64gx_curiosity_kit"
+
+config TEXT_BASE
+       default 0x80000000 if !RISCV_SMODE
+       default 0x80200000 if RISCV_SMODE
+
+config BOARD_SPECIFIC_OPTIONS # dummy
+       def_bool y
+       select MICROCHIP_MPFS
+       select BOARD_EARLY_INIT_F
+       select BOARD_LATE_INIT
+       imply SMP
+       imply CMD_DHCP
+       imply CMD_EXT2
+       imply CMD_EXT4
+       imply CMD_FAT
+       imply CMD_FS_GENERIC
+       imply CMD_NET
+       imply CMD_PING
+       imply CMD_MMC
+       imply DOS_PARTITION
+       imply EFI_PARTITION
+       imply IP_DYN
+       imply ISO_PARTITION
+       imply PHY_LIB
+       imply PHY_VITESSE
+       imply MTD_SPI_NAND
+       imply CMD_MTD
+       imply MTD_PARTITIONS
+       imply CMD_MTDPARTS
+       imply MPFS_PRIORITISE_QSPI_BOOT
+endif
diff --git a/board/microchip/pic64gx_curiosity_kit/MAINTAINERS b/board/microchip/pic64gx_curiosity_kit/MAINTAINERS
new file mode 100644
index 0000000000..13c8a2572b
--- /dev/null
+++ b/board/microchip/pic64gx_curiosity_kit/MAINTAINERS
@@ -0,0 +1,7 @@
+Microchip PIC64GX Curiosity kit
+M:     Pierre-Henry Moussay <pierre-henry.moussay@microchip.com>
+M:     Cyril Jean <cyril.jean@microchip.com>
+S:     Maintained
+F:     board/microchip/pic64gx_curiosity_kit/
+F:     include/configs/microchip_mpfs_discokit.h
+F:     configs/microchip_pic64gx_curiosity_kit_defconfig
diff --git a/board/microchip/pic64gx_curiosity_kit/Makefile b/board/microchip/pic64gx_curiosity_kit/Makefile
new file mode 100644
index 0000000000..d1206ef2c9
--- /dev/null
+++ b/board/microchip/pic64gx_curiosity_kit/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0+
+#
+# Copyright (C) 2024 Microchip Technology Inc.
+#
+
+obj-y += pic64gx_curiosity_kit.o
diff --git a/board/microchip/pic64gx_curiosity_kit/pic64gx_curiosity_kit.c b/board/microchip/pic64gx_curiosity_kit/pic64gx_curiosity_kit.c
new file mode 100644
index 0000000000..4e43d3cc38
--- /dev/null
+++ b/board/microchip/pic64gx_curiosity_kit/pic64gx_curiosity_kit.c
@@ -0,0 +1,377 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * Copyright (C) 2024 Microchip Technology Inc.
+ */
+
+#include <common.h>
+#include <dm.h>
+#include <env.h>
+#include <init.h>
+#include <malloc.h>
+#include <net.h>
+#include <asm/global_data.h>
+#include <asm/io.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define PIC64GX_SYSREG_SOFT_RESET         ((unsigned int *)0x20002088)
+#define PIC64GX_SYS_SERVICE_CR            ((unsigned int *)0x37020050)
+#define PIC64GX_SYS_SERVICE_SR            ((unsigned int *)0x37020054)
+#define PIC64GX_SYS_SERVICE_MAILBOX_U8    ((unsigned char *)0x37020800)
+#define PIC64GX_SYS_SERVICE_MAILBOX_U32   ((unsigned int *)0x37020800)
+
+#define SERVICE_CR_REQ_MASK            0x1u
+#define SERVICE_SR_BUSY_MASK           0x2u
+#define SERVICE_SR_STATUS_SHIFT        16
+#define SERVICE_CR_COMMAND_SHIFT       16
+
+#define SYS_SPI_CMD                    0x50
+#define SYS_SPI_MAILBOX_DATA_LEN       17
+#define SYS_SPI_MAILBOX_SRC_OFFSET     8
+#define SYS_SPI_MAILBOX_LENGTH_OFFSET  12
+#define SYS_SPI_MAILBOX_FREQ_OFFSET    16
+#define SYS_SPI_MAILBOX_FREQ           3
+#define SPI_FLASH_ADDR                 0x400
+
+#define PERIPH_RESET_VALUE             0x800001e8u
+
+/* Descriptor table */
+#define START_OFFSET                   4
+#define END_OFFSET                     8
+#define SIZE_OFFSET                    12
+#define DESC_NEXT                      12
+#define DESC_RESERVED_SIZE             0
+#define DESC_SIZE                      16
+
+#define BYTES_2                        2
+#define BYTES_4                        4
+#define BYTES_8                        8
+#define BYTES_16                       16
+#define BYTES_24                       24
+#define MASK_8BIT                      0xff
+
+#define DESIGN_MAGIC_0                 0x4d /* 'M' */
+#define DESIGN_MAGIC_1                 0x43 /* 'C'*/
+#define DESIGN_MAGIC_2                 0x48 /* 'H'*/
+#define DESIGN_MAGIC_3                 0x50 /* 'P'*/
+
+static u8 no_of_dtbo;
+static u32 dtbos_size;
+
+static void read_device_serial_number(u8 *response, u8 response_size)
+{
+	u8 idx;
+	u8 *response_buf;
+	unsigned int val;
+
+	response_buf = (u8 *)response;
+
+	writel(SERVICE_CR_REQ_MASK, PIC64GX_SYS_SERVICE_CR);
+	/*
+	 * REQ bit will remain set till the system controller starts
+	 * processing.
+	 */
+	do {
+		val = readl(PIC64GX_SYS_SERVICE_CR);
+	} while (SERVICE_CR_REQ_MASK == (val & SERVICE_CR_REQ_MASK));
+
+	/*
+	 * Once system controller starts processing the busy bit will
+	 * go high and service is completed when busy bit is gone low
+	 */
+	do {
+		val = readl(PIC64GX_SYS_SERVICE_SR);
+	} while (SERVICE_SR_BUSY_MASK == (val & SERVICE_SR_BUSY_MASK));
+
+	for (idx = 0; idx < response_size; idx++)
+		response_buf[idx] = readb(PIC64GX_SYS_SERVICE_MAILBOX_U8 + idx);
+}
+
+static u16 execute_sys_service(u8 cmd_opcode, u8 *cmd_data, u16 cmd_data_size)
+{
+	u32 *word_buf;
+	u32 mailbox_val;
+	u32 idx, value;
+	u16 status;
+	u8 *byte_buf;
+	u8 byte_offset;
+	u8 byte_idx;
+
+	word_buf = (u32 *)cmd_data;
+
+	for (idx = 0; idx < cmd_data_size / BYTES_4; idx++)
+		writel(word_buf[idx], PIC64GX_SYS_SERVICE_MAILBOX_U32 + idx);
+
+	if (cmd_data_size % BYTES_4 > 0) {
+		byte_offset = (cmd_data_size / BYTES_4) * BYTES_4;
+		byte_buf = (u8 *)(cmd_data + byte_offset);
+
+		mailbox_val = readl(PIC64GX_SYS_SERVICE_MAILBOX_U32 + idx);
+
+		for (byte_idx = 0; byte_idx < cmd_data_size % 4; byte_idx++) {
+			mailbox_val &= ~(MASK_8BIT << (byte_idx * BYTES_8));
+			value = byte_buf[byte_idx] << (byte_idx * BYTES_8);
+			mailbox_val |= value;
+		}
+		writel(mailbox_val, PIC64GX_SYS_SERVICE_MAILBOX_U32 + idx);
+	}
+
+	writel((cmd_opcode << SERVICE_CR_COMMAND_SHIFT) | SERVICE_CR_REQ_MASK,
+	       PIC64GX_SYS_SERVICE_CR);
+
+	/*
+	 * REQ bit will remain set till the system controller starts
+	 * processing.
+	 */
+	do {
+		value = readl(PIC64GX_SYS_SERVICE_CR);
+	} while (SERVICE_CR_REQ_MASK == (value & SERVICE_CR_REQ_MASK));
+
+	/*
+	 * Once system controller starts processing the busy bit will
+	 * go high and service is completed when busy bit is gone low
+	 */
+	do {
+		value = readl(PIC64GX_SYS_SERVICE_SR);
+	} while (SERVICE_SR_BUSY_MASK == (value & SERVICE_SR_BUSY_MASK));
+
+	status = value >> SERVICE_SR_STATUS_SHIFT;
+
+	return status;
+}
+
+static u16 sys_service_spi_copy(void *dst_addr, u32 src_addr, u32 length)
+{
+	u16 status;
+	u8 mailbox_format[SYS_SPI_MAILBOX_DATA_LEN];
+
+	*(u64 *)mailbox_format = (u64)dst_addr;
+	*(u32 *)(mailbox_format + SYS_SPI_MAILBOX_SRC_OFFSET) = src_addr;
+	*(u32 *)(mailbox_format + SYS_SPI_MAILBOX_LENGTH_OFFSET) = length;
+	mailbox_format[SYS_SPI_MAILBOX_FREQ_OFFSET] = SYS_SPI_MAILBOX_FREQ;
+
+	status = execute_sys_service(SYS_SPI_CMD, mailbox_format,
+				     SYS_SPI_MAILBOX_DATA_LEN);
+	return status;
+}
+
+static u16 get_dtbo_desc_header(u8 *desc_data, u32 desc_addr)
+{
+	u32 length, no_of_descs;
+	u16 status;
+
+	/* Get first four bytes to calculate length */
+	status = sys_service_spi_copy(desc_data, desc_addr, BYTES_4);
+	if (!status) {
+		/* Number of descriptors in dtbo descriptor */
+		no_of_descs = *((u32 *)desc_data);
+		if (no_of_descs) {
+			length = DESC_SIZE + ((no_of_descs - 1) * DESC_SIZE);
+			status = sys_service_spi_copy(desc_data, desc_addr,
+						      length);
+		} else {
+			status = -1;
+		}
+	}
+
+	return status;
+}
+
+static u8 *get_dtbo(u32 start_addr, u32 size)
+{
+	u16 status;
+	u8 *dtbo;
+
+	dtbo = (u8 *)malloc(size);
+	/* Get a dtbo from the spi flash */
+	status = sys_service_spi_copy(dtbo, start_addr + SPI_FLASH_ADDR,
+				      size);
+	if (status) {
+		free(dtbo);
+		dtbo = NULL;
+	}
+
+	return dtbo;
+}
+
+static void parse_desc_header(u8 *desc_header)
+{
+	u32 dtbo_desc_start_addr;
+	u32 dtbo_desc_end_addr;
+	u32 dtbo_desc_size;
+	u32 no_of_descs;
+	u16 idx, rsvd = 0;
+	u8 dtbo_name[16];
+	u8 dtbo_addr[20];
+	u8 *desc;
+	u8 *dtbo;
+
+	no_of_descs = *((u32 *)desc_header);
+
+	for (idx = 0; idx < no_of_descs; idx++) {
+		desc = &desc_header[START_OFFSET + (DESC_NEXT * idx) + rsvd];
+		dtbo_desc_start_addr = *((u32 *)desc);
+
+		desc = &desc_header[END_OFFSET + (DESC_NEXT * idx) + rsvd];
+		dtbo_desc_end_addr = *((u32 *)desc);
+
+		desc = &desc_header[SIZE_OFFSET + (DESC_NEXT * idx) + rsvd];
+		dtbo_desc_size = *((u32 *)desc);
+
+		if (no_of_descs)
+			rsvd += DESC_RESERVED_SIZE;
+
+		dtbo = get_dtbo(dtbo_desc_start_addr, dtbo_desc_size);
+		if (dtbo) {
+			sprintf(dtbo_name, "dtbo_image%d", no_of_dtbo);
+			sprintf(dtbo_addr, "0x%llx", (u64)dtbo);
+			env_set(dtbo_name, dtbo_addr);
+			++no_of_dtbo;
+			dtbos_size += dtbo_desc_size;
+		}
+	}
+}
+
+static void get_device_tree_overlays(void)
+{
+	u32 desc_length;
+	u32 dtbo_desc_addr;
+	u32 dtbo_addr[5];
+	u16 i, status, hart, no_of_harts;
+	u8 design_info_desc[256];
+	u8 dtbo_desc_data[256];
+	u8 no_of_dtbos[8];
+	u8 dtbo_size[8];
+	u8 *desc;
+
+	no_of_dtbo = 0;
+	dtbos_size = 0;
+
+	/* Read first 10 bytes to verify the descriptor is found or not */
+	status = sys_service_spi_copy(design_info_desc, SPI_FLASH_ADDR, 10);
+
+	if (!status && design_info_desc[0] == DESIGN_MAGIC_0 &&
+	    design_info_desc[1] == DESIGN_MAGIC_1 &&
+	    design_info_desc[2] == DESIGN_MAGIC_2 &&
+	    design_info_desc[3] == DESIGN_MAGIC_3) {
+		desc_length = *((u32 *)&design_info_desc[4]);
+		/* Read Design descriptor */
+		status = sys_service_spi_copy(design_info_desc,
+					      SPI_FLASH_ADDR, desc_length);
+		if (!status) {
+			no_of_harts = *((u16 *)&design_info_desc[10]);
+
+			for (hart = 0; hart < no_of_harts; hart++) {
+				/* Start address of DTBO descriptor */
+				desc = &design_info_desc[(0x4 * hart) + 0xc];
+
+				dtbo_desc_addr = *((u32 *)desc);
+				dtbo_addr[hart] = dtbo_desc_addr;
+
+				if (!dtbo_addr[hart])
+					continue;
+
+				for (i = 0; i < hart; i++) {
+					if (dtbo_addr[hart] == dtbo_addr[i])
+						continue;
+				}
+
+				if (hart && hart == i)
+					continue;
+
+				dtbo_desc_addr += SPI_FLASH_ADDR;
+				status = get_dtbo_desc_header(dtbo_desc_data,
+							      dtbo_desc_addr);
+				if (status)
+					continue;
+				else
+					parse_desc_header(dtbo_desc_data);
+			}
+		}
+	}
+	sprintf(no_of_dtbos, "%d", no_of_dtbo);
+	env_set("no_of_overlays", no_of_dtbos);
+	sprintf(dtbo_size, "%d", dtbos_size);
+	env_set("dtbo_size", dtbo_size);
+}
+
+int board_init(void)
+{
+	/* For now nothing to do here. */
+
+	return 0;
+}
+
+int board_early_init_f(void)
+{
+	unsigned int val;
+
+	/* Reset uart, mmc peripheral */
+	val = readl(PIC64GX_SYSREG_SOFT_RESET);
+	val = (val & ~(PERIPH_RESET_VALUE));
+	writel(val, PIC64GX_SYSREG_SOFT_RESET);
+
+	return 0;
+}
+
+int board_late_init(void)
+{
+	u32 ret;
+	u32 node_off;
+	u8 idx;
+	u8 device_serial_number[16] = { 0 };
+	ofnode node;
+	const u8 *initial_mac_addr;
+	unsigned char updated_mac_addr[ARP_HLEN];
+	char pic64gx_curiosity_kit_mac_addr[20];
+	void *blob = (void *)gd->fdt_blob;
+
+	node_off = fdt_path_offset(blob, "ethernet0");
+	if (node_off < 0) {
+		printf("No ethernet0 path offset\n");
+		return -ENODEV;
+	}
+
+	node = offset_to_ofnode(node_off);
+	initial_mac_addr = ofnode_read_u8_array_ptr(node, "local-mac-address",
+						    ARP_HLEN);
+	if (!initial_mac_addr) {
+		printf("No local-mac-address property\n");
+		return -EINVAL;
+	}
+
+	memcpy(updated_mac_addr, initial_mac_addr, ARP_HLEN);
+
+	read_device_serial_number(device_serial_number, 16);
+
+	/* Update MAC address with device serial number */
+	updated_mac_addr[0] = 0x00;
+	updated_mac_addr[1] = 0x04;
+	updated_mac_addr[2] = 0xA3;
+	updated_mac_addr[3] = device_serial_number[2];
+	updated_mac_addr[4] = device_serial_number[1];
+	updated_mac_addr[5] = device_serial_number[0];
+
+	ret = ofnode_write_prop(node, "local-mac-address", updated_mac_addr,
+				ARP_HLEN, true);
+	if (ret) {
+		printf("Error setting local-mac-address property\n");
+		return -ENODEV;
+	}
+	pic64gx_curiosity_kit_mac_addr[0] = '[';
+
+	sprintf(&pic64gx_curiosity_kit_mac_addr[1], "%pM", updated_mac_addr);
+
+	pic64gx_curiosity_kit_mac_addr[18] = ']';
+	pic64gx_curiosity_kit_mac_addr[19] = '\0';
+
+	for (idx = 0; idx < 20; idx++) {
+		if (pic64gx_curiosity_kit_mac_addr[idx] == ':')
+			pic64gx_curiosity_kit_mac_addr[idx] = ' ';
+	}
+	env_set("pic64gx_curiosity_kit_mac_addr0", pic64gx_curiosity_kit_mac_addr);
+
+	get_device_tree_overlays();
+
+	return 0;
+}
diff --git a/configs/microchip_pic64gx_curiosity_kit_defconfig b/configs/microchip_pic64gx_curiosity_kit_defconfig
new file mode 100644
index 0000000000..b221abd632
--- /dev/null
+++ b/configs/microchip_pic64gx_curiosity_kit_defconfig
@@ -0,0 +1,30 @@
+CONFIG_RISCV=y
+CONFIG_SYS_MALLOC_LEN=0x800000
+CONFIG_SYS_MALLOC_F_LEN=0x2000
+CONFIG_HAS_CUSTOM_SYS_INIT_SP_ADDR=y
+CONFIG_CUSTOM_SYS_INIT_SP_ADDR=0x80200000
+CONFIG_ENV_SIZE=0x2000
+CONFIG_DEFAULT_DEVICE_TREE="pic64gx-curiosity-kit"
+CONFIG_SYS_PROMPT="RISC-V # "
+CONFIG_SYS_LOAD_ADDR=0x80200000
+CONFIG_TARGET_MICROCHIP_PIC64GX_CURIOSITY=y
+CONFIG_ARCH_RV64I=y
+CONFIG_RISCV_SMODE=y
+CONFIG_FIT=y
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_DISPLAY_CPUINFO=y
+CONFIG_DISPLAY_BOARDINFO=y
+CONFIG_SYS_CBSIZE=256
+CONFIG_SYS_PBSIZE=282
+CONFIG_SYS_BOOTM_LEN=0x4000000
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_BOOTP_SEND_HOSTNAME=y
+CONFIG_DM_MTD=y
+CONFIG_SYSRESET=y
+CONFIG_CMD_MTDPARTS=y
+CONFIG_MTDPARTS_DEFAULT="mtdparts=spi-nand0:2m(payload),128k(env),119m(rootfs)"
+CONFIG_CMD_UBI=y
+CONFIG_CMD_UBIFS=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_LIMIT=20
+CONFIG_OF_LIBFDT_OVERLAY=y
diff --git a/include/configs/microchip_pic64gx_curiosity_kit.h b/include/configs/microchip_pic64gx_curiosity_kit.h
new file mode 100644
index 0000000000..6b4d4737f2
--- /dev/null
+++ b/include/configs/microchip_pic64gx_curiosity_kit.h
@@ -0,0 +1,72 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * Copyright (C) 2024 Microchip Technology Inc.
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <linux/sizes.h>
+
+#define CFG_SYS_SDRAM_BASE       0x80000000
+
+/* Environment options */
+
+#if defined(CONFIG_CMD_DHCP)
+#define BOOT_TARGET_DEVICES_DHCP(func)	func(DHCP, dhcp, na)
+#else
+#define BOOT_TARGET_DEVICES_DHCP(func)
+#endif
+
+#if defined(CONFIG_CMD_MMC)
+#define BOOT_TARGET_DEVICES_MMC(func)	func(MMC, mmc, 0)
+#else
+#define BOOT_TARGET_DEVICES_MMC(func)
+#endif
+
+#if defined(CONFIG_CMD_UBIFS)
+#define BOOT_TARGET_DEVICE_UBIFS(func)	func(UBIFS, ubifs, 0, ubi, rootfs)
+#else
+#define BOOT_TARGET_DEVICE_UBIFS(func)
+#endif
+
+#if defined(CONFIG_MPFS_PRIORITISE_QSPI_BOOT)
+#define BOOT_TARGET_DEVICES(func)	\
+	BOOT_TARGET_DEVICE_UBIFS(func)	\
+	BOOT_TARGET_DEVICES_MMC(func)	\
+	BOOT_TARGET_DEVICES_DHCP(func)
+#else
+#define BOOT_TARGET_DEVICES(func)	\
+	BOOT_TARGET_DEVICES_MMC(func)	\
+	BOOT_TARGET_DEVICES_DHCP(func)
+#endif
+
+#define BOOTENV_DESIGN_OVERLAYS \
+	"design_overlays=" \
+	"if test -n ${no_of_overlays}; then " \
+		"setenv inc 1; " \
+		"setenv idx 0; " \
+		"fdt resize ${dtbo_size}; " \
+		"while test $idx -ne ${no_of_overlays}; do " \
+			"setenv dtbo_name dtbo_image${idx}; " \
+			"setenv fdt_cmd \"fdt apply $\"$dtbo_name; " \
+			"run fdt_cmd; " \
+			"setexpr idx $inc + $idx; " \
+		"done; " \
+	"fi;\0 " \
+
+#if !defined(CONFIG_FIT_SIGNATURE)
+#include <config_distro_bootcmd.h>
+
+#define CFG_EXTRA_ENV_SETTINGS \
+	"bootm_size=0x10000000\0" \
+	"kernel_addr_r=0x80200000\0" \
+	"fdt_addr_r=0x8a000000\0" \
+	"fdtoverlay_addr_r=0x8a080000\0" \
+	"ramdisk_addr_r=0x8aa00000\0" \
+	"scriptaddr=0x8e000000\0" \
+	BOOTENV_DESIGN_OVERLAYS \
+	BOOTENV \
+
+#endif
+#endif /* __CONFIG_H */
-- 
2.30.2

